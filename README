Gabriel Boroghină
333CB

                            ASC Tema 3 - Parallel HashTable

Implementare

    Pentru implementarea tabelei hash paralele am folosit strategia de rezolvare
a coliziunilor <linear probing> (care este de tipul open addresing), iar pentru
fiecare valoare hash posibila am alocat 2 sloturi ce pot fi umplute cu perechi (key, value) (altfel
hash table-ul conține bucketuri de dimansiune 2).
    Astfel, fiecare inserare va

---------------------------------------------------------------------------------------------------
Stocare hash table în VRAM

    Pentru stocarea hash table-ului am folosit o structură hash_table, care reține
dimensiunea tabelei hash și 2 pointeri la câte un vector de sloturi în care se pot
introduce perechi (cheie, valoare). Folosirea a 2 pointeri se datorează implementării
bucketized.

---------------------------------------------------------------------------------------------------
Output rulare pe cluster

    Pentru testarea temei și evaluarea performanței am folosit coada hp-sl.q.
    Output-ul obținut la rularea checker-ului cu time este următorul:

    ('HASH_BATCH_INSERT, 100000, inf, 60.0002', ' OK')
    ('HASH_BATCH_GET, 100000, 10, 60.1538', ' OK')
    Test T1 20/20

    ('HASH_BATCH_INSERT, 2000000, 200, 60', ' OK')
    ('HASH_BATCH_GET, 2000000, 200, 60.0077', ' OK')
    Test T2 20/20

    ('HASH_BATCH_INSERT, 800000, inf, 60', ' OK')
    ('HASH_BATCH_INSERT, 800000, 40, 60', ' OK')
    ('HASH_BATCH_INSERT, 800000, 40, 60', ' OK')
    ('HASH_BATCH_INSERT, 800000, 40, 60', ' OK')
    ('HASH_BATCH_INSERT, 800000, inf, 75', ' OK')
    ('HASH_BATCH_GET, 800000, inf, 75.0048', ' OK')
    ('HASH_BATCH_GET, 800000, inf, 75.0048', ' OK')
    ('HASH_BATCH_GET, 800000, 80, 75.0048', ' OK')
    ('HASH_BATCH_GET, 800000, inf, 75.0048', ' OK')
    ('HASH_BATCH_GET, 800000, 80, 75.0048', ' OK')
    Test T3 10/10

    ('HASH_BATCH_INSERT, 10000000, 100, 60', ' OK')
    ('HASH_BATCH_GET, 10000000, 250, 60.0015', ' OK')
    Test T4 20/20

    ('HASH_BATCH_INSERT, 2000000, 100, 60', ' OK')
    ('HASH_BATCH_INSERT, 2000000, 66.6667, 60', ' OK')
    ('HASH_BATCH_INSERT, 2000000, 66.6667, 60', ' OK')
    ('HASH_BATCH_INSERT, 2000000, 40, 60', ' OK')
    ('HASH_BATCH_INSERT, 2000000, 66.6667, 75', ' OK')
    ('HASH_BATCH_GET, 2000000, inf, 75.0019', ' OK')
    ('HASH_BATCH_GET, 2000000, 200, 75.0019', ' OK')
    ('HASH_BATCH_GET, 2000000, 200, 75.0019', ' OK')
    ('HASH_BATCH_GET, 2000000, 100, 75.0019', ' OK')
    ('HASH_BATCH_GET, 2000000, 200, 75.0019', ' OK')
    Test T5 20/20


    TOTAL gpu_hashtable  90/90

    real    0m6.531s
    user    0m3.640s
    sys     0m2.501s

    Se observă o performanță semnificativ mai bună față de implementarea secvențială
bazată pe std::unordered_map (care durează aproximativ 29s).

---------------------------------------------------------------------------------------------------
Profiling nvprof

    Rezultatul analizei cu nvprof a executabilului pentru o un test foarte mare
(100 mil. de intrări în tabela hash, 10 iterații de insert/get):

==29747== Profiling application: ./gpu_hashtable 100000000 10
==29747== Profiling result:
            Type  Time(%)      Time     Calls       Avg       Min       Max  Name
 GPU activities:   34.94%  671.31ms        32  20.979ms  1.1520us  28.474ms  [CUDA memcpy HtoD]
                   29.71%  570.91ms         7  81.559ms  3.9040us  222.16ms  kernel_rehash(hash_table, hash_table)
                   18.17%  349.16ms        11  31.742ms  17.920us  40.216ms  kernel_insert(int*, int*, int, hash_table)
                   17.17%  329.95ms        10  32.995ms  30.759ms  39.712ms  kernel_get(int*, int*, int, hash_table)
                    0.00%  24.480us        16  1.5300us  1.2800us  3.0720us  [CUDA memset]


==29747== Unified Memory profiling result:
Device "Tesla K40m (0)"
   Count  Avg Size  Min Size  Max Size  Total Size  Total Time  Name
    2368  165.38KB  4.0000KB  0.9961MB  382.4375MB  61.49075ms  Device To Host
Total CPU Page faults: 1184
